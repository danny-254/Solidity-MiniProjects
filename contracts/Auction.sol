// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";

contract NFTAuction is AutomationCompatibleInterface {
    IERC721 private NFTContract;
    address payable private auctioneer;
    uint256 public initialPrice;
    uint256 public highestBid;
    uint256 public currentBidPrice;
    address public highestBidder;
    uint256 public immutable tokenId;
    address public immutable tokenContract;
    mapping(uint256 => address) public bidsRegister;
    uint256[] private amounts;
    uint256 startTime;
    uint256 interval; 
    enum AuctionStatus {OPEN, CLOSED}
    AuctionStatus status;

    // The interval is the time with which the auction runs


    constructor(address _auctioneer, uint256 _startPrice, uint256 _tokenId, address _tokenContract, uint256 _runningTime) {
        auctioneer = payable(_auctioneer);
        initialPrice = _startPrice;
        tokenId = _tokenId;
        tokenContract = _tokenContract;
        status = AuctionStatus.CLOSED;
        interval = _runningTime;
        NFTContract = IERC721(_tokenContract);
    }

    event AuctionState(AuctionStatus _status);

    modifier onlyAuctioneer {
        require(msg.sender == auctioneer, "Only the contract owner can call this function");
        _;
    }

    modifier isApproved {
        require(NFTContract.isApprovedForAll(auctioneer, address(this)), "Contract is not approved to transfer NFT");
        _;
    }

    function startAuction() external onlyAuctioneer {
        require(status == AuctionStatus.CLOSED, "The Auction is already open");
        status = AuctionStatus.OPEN;
        startTime = block.timestamp;
        // highestBid = initialPrice;
        emit AuctionState(status);
    }

    function batchTransfer() private {
        for(uint256 i = 0; i < amounts.length - 1; i++) {
            uint256 amountOwed = amounts[i];
            address bidderAddress = bidsRegister[amountOwed];
            (bool success, ) = payable(bidderAddress).call{value: amountOwed}("");
            // (bool success, ) = bidsRegister[amounts[i]].call{value: amounts[i]}("");
            require(success);
        }
    }

    function closeAuction() private isApproved {
        require(status == AuctionStatus.OPEN, "The Auction is already closed");
        status = AuctionStatus.CLOSED;
        emit AuctionState(status);
        highestBid = currentBidPrice;
        highestBidder = bidsRegister[currentBidPrice];
        NFTContract.transferFrom(auctioneer, highestBidder, tokenId);
        batchTransfer();
        (bool success, ) = auctioneer.call{value: highestBid}("");
        require(success);
    }

    function bid() external payable {
        require(status == AuctionStatus.OPEN, "The Auction is already closed");
        require(msg.value > currentBidPrice, "You can't bid lower");
        bidsRegister[msg.value] = msg.sender;
        currentBidPrice = msg.value;
        amounts.push(msg.value);
    }

    // Implementing the chainlink upkeep to autoclose the auction

    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        upkeepNeeded = (block.timestamp - startTime) >= interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - startTime) >= interval ) {
            closeAuction();
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    // Destroying the contract instance deployed

    function destroy() public payable{
        selfdestruct(auctioneer);
    }
}